/**
 *
 * Version : $Id$
 * This file was generated by Aldebaran Robotics ModuleGenerator
 */

#include "onfacedetection.h"

#include <alvalue/alvalue.h>
#include <alcommon/alproxy.h>
#include <alcommon/albroker.h>
#include <althread/alcriticalsection.h>
#include <alproxies/almotionproxy.h>

#include <qi/log.hpp>
#define WIB (+7)

OnFaceDetection::OnFaceDetection(
  boost::shared_ptr<AL::ALBroker> broker,
  const std::string& name):
    AL::ALModule(broker, name),
    fMemoryProxy(getParentBroker()),
	motion(getParentBroker()),
	robotPosture(getParentBroker()),
    fFaces(AL::ALValue()),
    fFacesCount(0),
    fCallbackMutex(AL::ALMutex::createALMutex())
{
  setModuleDescription("This is an autogenerated module, this descriptio needs to be updated.");

  functionName("callback", getName(), "");
  BIND_METHOD(OnFaceDetection::callback)

}

OnFaceDetection::~OnFaceDetection() {}

void OnFaceDetection::init() {
  try {
    /** See if there is any face already detected at initialization. */
    fFaces = fMemoryProxy.getData("FaceDetected");
    if (fFaces.getSize() < 2) {
      qiLogInfo("module.example") << "No face detected" << std::endl;
//      fTtsProxy.say("No face detected");
    }
    /** Subscribe to the event FaceDetected, with appropriate callback function. */
    fMemoryProxy.subscribeToEvent("FaceDetected", "OnFaceDetection", "callback");
  }
  catch (const AL::ALError& e) {
    qiLogError("module.name") << e.what() << std::endl;
  }
}

void OnFaceDetection::callback() {
  /** Use a mutex to make it all thread safe. */
  AL::ALCriticalSection section(fCallbackMutex);
  try {
    /** Retrieve the data raised by the event. */
    fFaces = fMemoryProxy.getData("FaceDetected");
    /** Check that there are faces effectively detected. */
    if (fFaces.getSize() < 2 ) {
      if (fFacesCount != 0) {
        qiLogInfo("module.example") << "No face detected" << std::endl;
//        fTtsProxy.say("No face detected.");
        fFacesCount = 0;
      }
      return;
    }
    /** Check the number of faces from the FaceInfo field, and check that it has
    * changed from the last event.*/
    if (fFaces[1].getSize() - 1 != fFacesCount) {
      qiLogInfo("module.name") << fFaces[1].getSize() - 1 << " face(s) detected." << std::endl;
      char buffer[50];
      sprintf(buffer, "%d faces detected.", fFaces[1].getSize() - 1);
//      fTtsProxy.say(std::string(buffer));
	  char bufferGreeting[50];
	  
	  time_t waktu;
	  struct tm * ptm;
	  time ( &waktu );
	  ptm = gmtime ( &waktu );
	  int jam=(ptm->tm_hour+WIB)%24;

	  if (jam>=6&&jam<=12){
			sprintf(bufferGreeting, "Good morning");
	  } else if(jam>=12&&jam<=16){
		  sprintf(bufferGreeting, "Good afternoon");
	  } else if(jam>=16&&jam<=21){
		  sprintf(bufferGreeting, "Good evening");
	  } else{
		  sprintf(bufferGreeting, "Hello");
	  }

	  fTtsProxy.say(bufferGreeting);
	  /*Memberi hormat*/
	  bool isAbsolute = true;
	  AL::ALValue Names       = AL::ALValue::array("RShoulderRoll", "LShoulderRoll");
    AL::ALValue Angles      = AL::ALValue::array(0.0f, 0.0f);
	AL::ALValue Times		= AL::ALValue::array(0.0f, 0.0f);
	AL::ALValue Stiffon		= AL::ALValue::array(1.0f, 1.0f);
	AL::ALValue Stiffoff	= AL::ALValue::array(0.0f, 0.0f);
	float fractionMaxSpeed  = 0.2f; 
	

	  Names       = AL::ALValue::array("RShoulderRoll", "RElbowYaw", "RElbowRoll", "RShoulderPitch");
    Angles      = AL::ALValue::array(-0.3f, 0.9f, 2.3f, .0f);
    
	fractionMaxSpeed  = 0.1f;
 
    motion.setStiffnesses(Names, AL::ALValue::array(1.0f, 1.0f, 1.0f, 1.0f));
    qi::os::sleep(1.0f);
    motion.setAngles(Names, Angles, fractionMaxSpeed);
    qi::os::sleep(1.0f);
    motion.setStiffnesses(Names, AL::ALValue::array(1.0f, 1.0f, 1.0f, 1.0f));

	motion.openHand("RHand");
    motion.stiffnessInterpolation("RHand", 0.0f, 1.0f);
	motion.closeHand("RHand");
	motion.stiffnessInterpolation("RHand", 0.0f, 0.2f);

	Names       = AL::ALValue::array("RShoulderRoll", "LShoulderRoll");
	
	Angles.clear();
	Angles.arraySetSize(2);
	Angles[0] = AL::ALValue::array(0.0f);
	Angles[1] = AL::ALValue::array(0.0f);

	Times.clear();
	Times.arraySetSize(2);
	Times[0] = AL::ALValue::array(0.5f);
	Times[1] = AL::ALValue::array(0.5f);

	Stiffon		= AL::ALValue::array(1.0f, 1.0f);
	Stiffoff	= AL::ALValue::array(0.0f, 0.0f);
	
	motion.setStiffnesses(Names, Stiffon);
    motion.angleInterpolation(Names, Angles, Times, isAbsolute);
	robotPosture.goToPosture("Crouch", 1.0f);
	motion.rest();
	  /**/
      /** Update the current number of detected faces. */
      fFacesCount = fFaces[1].getSize() - 1;
    }
  }
  catch (const AL::ALError& e) {
    qiLogError("module.name") << e.what() << std::endl;
  }
}
